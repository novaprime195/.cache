# Git Offline Multi-user Guide — Step-by-step Answer Sheet

**Goal:** Demonstrate how to use Git on a single local machine to simulate multiple users (team leader + coders), show branching (fork), merging, diffs, conflict resolution, and compare Git workflows with SVN. All examples are runnable on a local machine (offline).

---

## Table of contents

1. Overview: Git vs SVN (quick summary)
2. Setup: prerequisites
3. Create a *central* bare repository (acts like server) — offline
4. Create local clones for multiple users (team_lead, coder1, coder2)
5. Per-user Git configuration (local repo-level user identity)
6. Typical workflow: branching (feature branches), pull, push, merge by team leader
7. Demonstrate fork (local clone), branch, and merge
8. Demonstrate `git diff`, `git log`, `git blame` and other inspection tools
9. Conflict scenario and step-by-step resolution (three-way merge)
10. Advanced: rebasing vs merging, protecting main branch (simulated policy)
11. Comparison with SVN: commands, branching model, merging, pros/cons
12. Appendix: quick command reference and cheat sheet

---

## 1) Overview: Git vs SVN (short)

* **Git** is a distributed version control system. Each clone is a full repository with full history. Branching and merging are cheap and common.
* **SVN (Subversion)** is a centralized VCS: a single central repository stores history; users checkout working copies and `commit` back to the central server. Branching exists but is heavier and less used than in Git.

High-level differences you will see in practice:

* Offline work: **Git** supports full offline commits and history operations; **SVN** requires network access to commit to the central repo.
* Branching/forging: Git branches are lightweight; SVN branches are directory copies on the server.
* Merging: Git has sophisticated merge algorithms and local merge commits or rebases; SVN merging historically had pains like tracking mergeinfo properties.

---

## 2) Setup: prerequisites (local machine)

* Install git (Git 2.x+). On Debian/Ubuntu: `sudo apt-get install git` (offline assume already installed).
* A shell (bash / zsh / PowerShell on Windows).
* You will run several repositories as different users in different directories.

Paths used in examples (you can adapt):

```
/home/you/git-demo/
├─ central-repo.git            # bare central repository
├─ team_lead/                  # clone for team leader
├─ coder1/                     # clone for coder1
└─ coder2/                     # clone for coder2
```

Create a working directory:

```bash
mkdir -p ~/git-demo && cd ~/git-demo
```

---

## 3) Create a bare central repository (acts as offline server)

A *bare* repository has no working tree and is used as a shared central repo.

```bash
# create a bare repo
git init --bare central-repo.git
```

This folder acts like `origin` for your clones. Because it's local, it's fully offline but simulates a central server.

---

## 4) Create local clones for multiple users

We will clone the central bare repo into three directories to represent three users.

```bash
# Team leader clone
git clone central-repo.git team_lead
# Coder 1 clone
git clone central-repo.git coder1
# Coder 2 clone
git clone central-repo.git coder2
```

Now each directory is an independent repo that can push/pull to `../central-repo.git`.

---

## 5) Per-user Git configuration (set identity per clone)

Git identity (`user.name` and `user.email`) is used for commits. Set identity per local clone (don't use --global if simulating different people).

```bash
# Team leader
cd ~/git-demo/team_lead
git config user.name "Team Lead"
git config user.email "lead@example.local"

# Coder1
cd ../coder1
git config user.name "Coder One"
git config user.email "coder1@example.local"
ls
# Coder2
cd ../coder2
git config user.name "Coder Two"
git config user.email "coder2@example.local"
```

To verify:

```bash
git config user.name   # prints configured name
git config user.email
```

> Note: these settings are stored inside the repo's `.git/config` and affect only that clone.

---

## 6) Seed repository with initial files (done by team lead)

Team leader initializes project files and pushes to central.

```bash
cd ~/git-demo/team_lead
# create a simple file
mkdir src && echo "print('Hello world')" > src/main.py
# stage and commit
git add .
git commit -m "Initial commit: add main.py"
# push to central
git push origin master
```

Now central has the master (main) branch with one commit.

---

## 7) Typical workflow: branching (feature branches), push/pull, merge

We'll simulate coder1 and coder2 creating feature branches, working, and team leader merging them.

### Coder1: create feature branch and work

```bash
cd ~/git-demo/coder1
# fetch latest from central
git pull origin master
# create and switch to feature branch
git checkout -b feature/ui-improvement
# modify the code
echo "# UI improvements" >> src/main.py
# commit
git add src/main.py
git commit -m "Feature: UI improvements by Coder One"
# push branch to central
git push origin feature/ui-improvement
```

### Coder2: create feature branch and work

```bash
cd ~/git-demo/coder2
git pull origin master
git checkout -b feature/add-logging
echo "\nprint('Logging enabled')" >> src/main.py
git add src/main.py
git commit -m "Feature: add logging by Coder Two"
git push origin feature/add-logging
```

### Team lead: review and merge branches into master

Team lead fetches remote branches, reviews diffs, tests, then merges.

```bash
cd ~/git-demo/team_lead
git fetch origin
# list remote branches
git branch -r

# inspect feature branch diff
git checkout -b review-ui origin/feature/ui-improvement
git diff origin/master..origin/feature/ui-improvement
# after review, merge into master (fast-forward or with merge commit)
git checkout master
git pull origin master   # ensure up to date
git merge --no-ff review-ui -m "Merge feature/ui-improvement (reviewed)"
# push updated master
git push origin master

# Repeat for coder2's branch
git fetch origin
git checkout -b review-logging origin/feature/add-logging
# test, then merge
git checkout master
git merge --no-ff review-logging -m "Merge feature/add-logging (reviewed)"
git push origin master
```

**Notes:**

* `--no-ff` forces a merge commit so merges are recorded explicitly.
* Alternatively, team lead could `rebase` coder branches before merging to keep linear history.

---

## 8) Demonstrate fork (local clone), branching and code diff

### Fork (local clone) — simulate a forked repository

A fork on hosting services creates a separate copy of a repository under a different owner. Locally we can simulate by cloning the central repo into `coder1-fork`:

```bash
cd ~/git-demo
git clone central-repo.git coder1-fork
cd coder1-fork
# change user identity to simulate different owner
git config user.name "Coder One Fork"
```

Work in this fork, then add the original central repository as `upstream` and push your branch to the fork. To get changes merged upstream, you would typically create a pull request on hosted services. Locally, the team lead can add the fork as a remote and pull the branch.

### Show diffs

* To see unstaged changes: `git diff`
* To see staged vs last commit: `git diff --staged`
* To compare two branches: `git diff master..feature/add-logging`
* To see commit-level differences: `git log --oneline --graph --decorate --all`

Example:

```bash
# from team_lead clone
git fetch origin
git diff origin/master..origin/feature/add-logging
```

---

## 9) Conflict scenario and resolution (step-by-step)

Simulate both coder1 and coder2 editing the same line in `src/main.py` and then both trying to merge into master.

### Setup: both base off master

Assume master currently has the same initial content.

Coder1 edits a line:

```bash
cd ~/git-demo/coder1
git checkout -b feature/conflict-test
# edit line 3 in src/main.py
sed -n '1,100p' src/main.py
# simulate edit
printf "print('Hello from Coder One')\n" > src/main.py
git add src/main.py
git commit -m "Coder One: change greeting"
git push origin feature/conflict-test
```

Coder2 edits the same line differently:

```bash
cd ~/git-demo/coder2
git checkout -b feature/conflict-test
printf "print('Hello from Coder Two')\n" > src/main.py
git add src/main.py
git commit -m "Coder Two: change greeting"
# push to remote
git push origin feature/conflict-test-c2
```

Now the team lead attempts to merge coder2's change first, then coder1's change.

```bash
cd ~/git-demo/team_lead
# merge coder2 branch into master
git fetch origin
git checkout master
git merge origin/feature/conflict-test-c2
# push master
git push origin master

# now try to merge coder1
git merge origin/feature/conflict-test
# this will produce a conflict
```

### Resolve conflict

Git will mark the conflicting file with conflict markers `<<<<<<<`, `=======`, `>>>>>>>`.

Open the file, find markers, and decide desired content. Example:

```text
<<<<<<< HEAD
print('Hello from Coder Two')
=======
print('Hello from Coder One')
>>>>>>> origin/feature/conflict-test
```

Choose a resolution (e.g. combine or choose one). Edit file to final content:

```text
print('Hello from Team: merged greetings')
```

Then finish the merge:

```bash
git add src/main.py
git commit -m "Resolve conflict between coder1 and coder2 greetings"
git push origin master
```

Alternative: you can ask the original authors to rebase their branch on top of latest master and resolve locally, then push.

---

## 10) Advanced: rebase vs merge, protecting main branch (simulated)

* `git merge` creates a merge commit that keeps history of both branches.
* `git rebase` replays commits on top of another branch for a linear history.

Team lead policy examples:

* Require feature branches to be rebased onto latest master before merging (clean linear history).
* Or use merge commits to preserve branch history. Both are valid; choose one for your team.

To rebase a branch (example done by coder):

```bash
# on coder1 branch
git fetch origin
git checkout feature/x
git rebase origin/master
# fix any conflicts, then push
git push --force-with-lease origin feature/x
```

`--force-with-lease` is safer than plain force push because it prevents overwriting remote work unexpectedly.

---

## 11) Comparison with SVN (concrete commands and workflow differences)

### SVN quick commands (centralized):

```
# checkout repository (one-time)
svn checkout file:///path/to/central-svn repo
cd repo
# make edit
svn add newfile
svn commit -m "message"
# update working copy with others' commits
svn update
# create branch (copy on the server)
svn copy ^/trunk ^/branches/my-branch -m "create branch"
# merge branch back to trunk
svn switch ^/branches/my-branch
svn merge ^/trunk
svn commit -m "merge back"
```

### Key differences you will notice:

* **Offline commits:** Git allows full local commits and local history; SVN requires network for commit (unless using svnsync or local dump).
* **Branches:** In SVN, branches are directory copies on the server and can be heavier to manage. In Git, branches are local objects and cheap to create/switch.
* **Merging and metadata:** SVN stores `svn:mergeinfo` properties to track merges; this can cause clutter and complexity. Git stores the full graph and uses commit-parent relationships.
* **Permissions & central control:** SVN central server gives straightforward centralized permission control. Git central workflows often implement policies with server hooks, protected branches on hosting services, or review systems.

**Which to use?** For modern development and distributed/offline workflows, Git is the better choice. SVN may still be used for legacy centralized workflows or where central control/policy is required.

---

## 12) Appendix: quick command reference & cheatsheet

### Setup & identity

```bash
git init --bare central-repo.git
git clone central-repo.git team_lead
git config user.name "Name"
git config user.email "you@example.com"
```

### Basic workflow

```bash
git status
git add file
git commit -m "message"
git push origin branch
git pull origin master
```

### Branching & forks

```bash
git checkout -b feature/xyz
git branch           # list local branches
git branch -r        # list remote branches
# to simulate fork: git clone central-repo.git fork-dir
```

### Merging & rebasing

```bash
git checkout master
git merge feature/xyz          # merge with commit
git rebase origin/master       # rebase
git push --force-with-lease   # if rebased and pushing
```

### Diff & history inspection

```bash
git diff                      # unstaged changes
git diff --staged             # staged
git diff master..feature/x
git log --oneline --graph --decorate --all
git blame path/to/file
```

### Conflict resolution

1. `git status` shows conflicted files
2. open file(s), resolve between markers
3. `git add <file>`
4. `git commit` to finish merge

---

## Final notes and suggested exercises (hands-on)

Try these exercises on your machine:

1. Create the central bare repo and three clones as shown above.
2. Have coder1 and coder2 create feature branches, make commits, and push.
3. Have the team lead merge branches and intentionally create conflicts to practice resolution.
4. Try the `rebase` workflow and observe history differences using `git log --graph`.
5. Simulate a fork: clone into `coder1-fork`, push a branch there, then pull that branch into the central repo and merge.

If you want, I can also produce a printable PDF or a one-page cheat sheet from this document. Tell me which format you prefer.

---

**End of answer sheet**
